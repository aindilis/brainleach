(defoperator CD ((directory ?d) (path ?n))
 (declare ((directory ?old) (path ?oldpath)))
 (documentation "Change the current working directory")
 (precond (satisfy (pathname ?d ?n)))
 (undo-cond (and (satisfy (current.directory ?old))
	     (satisfy (pathname ?old ?oldpath))))
 (interface ((exec-func execute-unix-command)
	     (translation ("cd " ?n))
	     (undo-trans ("cd " ?oldpath))
	     (error-func default-unix-error?)
	     (terminate-detect read-unix-prompt)))
 (effect (cause (current.directory ?d))))

(defoperator FIND-FILE ((path ?pathname) (file !file))
 (precond (satisfy (current.shell csh)))
 (effect (observe (pathname !file ?pathname)))
 (interface ((exec-func execute-unix-command)
	     (sense-func ( (!file) (find-file-sense :new)))
	     (translation ("ls -dF " ?pathname))
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (error-func no-error))))

(defoperator LS ((directory ?d) (path ?dp))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (pathname ?d ?dp))))
 (effect (forall ((file !f))
	  (exists ((path !p) (filename !n))
	   (when (parent.directory !f ?d)
	    (and (observe (parent.directory !f ?d))
	     (observe (pathname !f !p))
	     (observe (filename !f !n)))))))
 (interface ((exec-func execute-unix-command)
	     (translation ("ls -F " ?dp))
	     (sense-func ((!f !n !p) (ls-sense ?dp :new)))
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (error-func default-unix-error?)
	     (terminate-detect read-unix-prompt))))

(defoperator PWD ((directory !dir))
 (declare ((path !path)
	   (filename !name)))
 (precond (satisfy (current.shell csh)))
 (effect (when (current.directory !dir)
	  (and (observe (current.directory !dir))
	   (observe (pathname !dir !path))
	   (observe (filename !dir !name)))))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!path !name !dir) (pwd-sense :new)))
	     (translation ("pwd")))))

(defoperator WC ((simple.file ?x) (number !char) (number !word)
		 (number !line) (directory ?dir))
 (declare ((filename ?name)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (current.directory ?dir))
	   (satisfy (parent.directory ?x ?dir))
	   (satisfy (filename ?x ?name))))
 (effect (and (observe (character.count ?x !char))
	  (observe (word.count ?x !word))
	  (observe (line.count ?x !line))))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!char !word !line) (wc-sense)))

	     (error-func default-unix-error?)
	     (translation ("wc \"" ?name "\"")))))

(defoperator GREP ((string ?string) (simple.file ?x) (bool !grep-t))
 (declare ((filename ?nm) (directory ?d)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (current.directory ?d))
	   (satisfy (filename ?x ?nm))
	   (satisfy (parent.directory ?x ?d))))
 (effect (observe (string.in.file ?string ?x) !grep-t))
 (interface ((exec-func execute-unix-command)
	     (sense-func ((!grep-t) grep-sense))
	     (error-func no-error)
	     (translation ("grep " ?string " " ?nm)))))

(defoperator OWNER-OF-FILE ((file ?x) (userid !owner))
 (declare ((filename ?nm) (directory ?d)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (current.directory ?d))
	   (satisfy (parent.directory ?x ?d))
	   (satisfy (filename ?x ?nm))))
 (effect (and (observe (owner ?x !owner))))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!owner) owner-of-file-sense))
	     (translation ("ls -lLd " ?nm )))))

(defoperator PROTECTION-ON-FILE ((file ?x) (bool !g-read)
				 (bool !g-write) (bool !g-exec))
 (declare ((path ?nm)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (pathname ?x ?nm))))
 (effect (and (observe (group.protection ?x readable) !g-read)
	  (observe (group.protection ?x writeable) !g-write)
	  (observe (group.protection ?x executable) !g-exec)))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!g-read !g-write !g-exec)
			  (protect-on-file-sense)))
	     (translation ("ls -lLd " ?nm )))))

(defoperator GROUP-PROTECT-FILE ((file ?x))
 (declare ((path ?nm)
	   (userid ?person)))
 (precond (and (satisfy (current.shell
			 (satisfy (current.userid csh))
			 ?person))
	   (satisfy (owner ?x ?person))
	   (satisfy (pathname ?x ?nm))))
 (effect (and (cause (group.protection ?x readable))
	  (cause (group.protection ?x writeable))
	  (cause (group.protection ?x executable))))
 (interface ((exec-func execute-unix-command)
	     (translation ("chmod g+rwx " ?nm )))))

(defoperator GROUP-UNPROTECT-FILE ((file ?x))
 (declare ((path ?nm)
	   (userid ?person)))
 (precond (and (satisfy (current.shell
			 (satisfy (current.userid csh))
			 ?person))
	   (satisfy (owner ?x ?person))
	   (satisfy (pathname ?x ?nm))))
 (effect (and (cause (group.protection ?x readable) F)
	  (cause (group.protection ?x writeable) F)
	  (cause (group.protection ?x executable) F)))
 (interface ((exec-func execute-unix-command)
	     (translation ("chmod g-rwx " ?nm )))))

(defoperator MOVE-DIR ((file ?x) (directory ?d2))
 (declare ((filename ?nm)
	   (path ?d2path)
	   (directory ?d)))
 (precond (and (satisfy (current.directory ?d))
	   (satisfy (pathname ?d2 ?d2path))
	   (satisfy (parent.directory ?x ?d))
	   (satisfy (filename ?x ?nm))
	   (satisfy (current.shell csh))))
 (effect (cause (parent.directory ?x ?d2)))
 (interface ((exec-func execute-unix-command)
	     (translation ("mv " ?nm " " ?d2path)))))

(defoperator COMPARE-LENGTH ((file ?f1) (file ?f2) (number ?l1)
			     (number ?l2) (bool !t))
 (declare (directory ?d))
 (precond (and (satisfy (parent.directory ?f1 ?d))
	   (satisfy (parent.directory ?f2 ?d))
	   (satisfy (character.count ?f1 ?l1))
	   (satisfy (character.count ?f2 ?l2))))
 (effect (observe (same.length ?f1 ?f2) !t))
 (interface ((exec-func execute-lisp-command)
	     (sense-func ((!t) lisp-true?))
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (error-func null-function)
	     (translation (compare-length-sense ?l1 ?l2)))))

(defoperator GET-PATH ()
 (precond (satisfy (current.shell csh)))
 (effect (forall ((directory !d))
	  (exists ((path !p))
	   (when (current.path !d)
	    (and (observe (pathname !d !p))
	     (observe (current.path !d)))))))
 (interface ((exec-func execute-unix-command)
	     (translation ("echo $path"))
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!d !p) (get-path-sense :new))))))

(defoperator ADD-PATH ((directory ?dir))
 (declare ((path ?dirname)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (pathname ?dir ?dirname))
	   (satisfy (current.path ?dir) f)))
 (effect (cause (current.path ?dir)))
 (interface ((exec-func execute-unix-command)
	     (error-func default-unix-error?)
	     (translation ("set path = ( " ?dirname " $path )")))))

(defoperator RESET-PATH ()
 (precond (satisfy (current.shell csh)))
 (effect (and (forall ((directory !path))
	       (when (current.path !path)
		(cause (current.path !path) F)))
	  (cause (current.path.reset) t)))
 (interface ((exec-func execute-unix-command)
	     (translation ("set path = (/bin)")))))

(defoperator netfind ((person ?person))
 (declare ((machine ?server)
	   (machine.name ?server-name)
	   (number ?time) (number ?current-time) (bool !busy)
	   (number ?now)
	   (city ?city) (field ?field) (state ?state)
	   (country ?country)
	   (organization ?organization) (person ?person)
	   (domain !domain) (string ?key1)
	   (string ?key2) (string ?key3)
	   (userid !userid) (firstname ?first)
	   (lastname ?last) (first.initial ?fi)
	   (organization ?affiliation)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (machine.netfind.server ?server))
	   (satisfy (machine.name ?server ?server-name))
	   (or (contemplate (server.busy ?server? ?time) u)
	    (and
	     (contemplate (server.busy ?server ?time))
	     (contemplate (seconds-ago ?time 300))))))
 (effect (and
	  (when (and (eq !busy (bool t))
		 (contemplate (universal-time ?current-time)))
	   (observe (server.busy ?server ?current-time)))
	  (when (eq !busy (bool f))
	   (and (observe (server.busy ?server ?time) u)
	    (when (and (neq !userid (userid "notfound"))
		   (or (city ?person ?key1)
		    (organization ?person ?key1)
		    (affiliation ?person ?key1))
		   (or (country ?person ?key2)
		    (state ?person ?key2)
		    (eq ?key2 ""))
		   (or (field ?person ?key3)
		    (eq ?key3 "")))
	     (and
	      (when (and (person.domain ?person !domain)
		     (userid ?person !userid !domain))
	       (and
		(when (city ?person ?key1)
		 (observe (city ?person ?city)))
		(when (organization ?person ?key1)
		 (observe (organization ?person ?organization)))
		(when (affiliation ?person ?key1)
		 (affiliation ?person ?affiliation))

		(when (country ?person ?key2)
		 (observe (country ?person ?country)))
		(when (state ?person ?key2)
		 (observe (state ?person ?state)))

		(when (field ?person ?key3)
		 (observe (field ?person ?field)))

		(when (first.initial ?person ?fi)
		 (observe (first.initial ?person ?fi)))
		(when (firstname ?person ?first)
		 (observe (firstname ?person ?first)))
		(when (lastname ?person ?last)
		 (observe (lastname ?person ?last)))))))))))
 (interface ((exec-func execute-unix-command)
	     (sense-func (!busy !userid !domain
			  (netfind-sense ?first ?last)))
	     (logical-sense-call t)
	     (translation ("netfind.exp " ?server-name " '"
			   ?last " " ?key1 " " ?key2 " "
			   ?key3
			   "'")))))

(defoperator WHOAMI ((userid !userid))
 (precond (satisfy (current.shell csh)))
 (effect (and (observe (current.userid !userid))))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!userid) bind-output-to-string))
	     (translation ("whoami")))))

(defoperator FINGER ((string ?string))
 (declare ((machine ?machine)
	   (machine.name ?name) (domain ?domain)
	   (bool !unfingerable)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (domain.machine.name ?domain ?name))
	   (satisfy (machine.name ?machine ?name))
	   (satisfy (machine.alive ?machine?))))
 (effect
  (and
   (observe (machine.unfingerable ?machine) !unfingerable)
   (forall ((person !person))
    (exists
     ((firstname !firstname) (lastname !lastname)
      (userid !userid) (first.initial !fi)
      (finger.record !record))
     (when (and (eq !unfingerable (bool u))
	    (person.domain !person ?domain)
	    (or (lastname !person ?string)
	     (firstname !person ?string)
	     (and (userid !person ?string ?domain)
	      (eq ?string !userid))))
      (and
       (observe (userid !person !userid ?domain))
       (observe (first.initial !person !fi))
       (observe (person.domain !person ?domain))
       (observe (firstname !person !firstname))
       (observe (lastname !person !lastname))
       (observe (finger.record !person !record
		 ?domain))))))))
 (interface ((exec-func execute-unix-command-downcase)
	     (sense-func (!unfingerable
			  (!person !userid !firstname !lastname !record !fi)
			  (finger-sense ?string :new)))
	     (logical-sense-call t)
	     (translation ("finger " ?string "@" ?domain)))))

(defoperator FINGER-MACHINE-GREP-USERID ((userid ?userid)
					 (machine ?machine)
					 (bool !finger-t)
					 (number !idle-time)
					 (bool !is-active))
 (declare ((machine.name ?machine-name)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (machine.name ?machine? ?machine-name))
	   (satisfy (machine.alive ?machine?))))
 (effect (and (observe (logged.on ?userid ?machine) !finger-t)
	  (observe (idle.time ?userid ?machine !idle-time))
	  (observe (active.on ?userid ?machine) !is-active)))
 (interface ((exec-func execute-unix-command)
	     (sense-func ((!finger-t !idle-time !is-active)
			  (finger-user-sense ?userid)))
	     (translation ("finger @" ?machine-name
			   " |& egrep '^"
			   ?userid "|Login|User'")))))

(defoperator STAFFDIR ((lastname ?lastname))
 (precond (and (satisfy (current.shell csh))))
 (effect
  (and (observe (staffdir.record ?lastname))
   (forall ((person !person))
    (exists
     ((domain !domain)
      (userid !userid)
      (machine !machine)
      (machine.name !machine-name)
      (string !room) (phone.number !phone)
      (title !title) (department !dept) (mailbox !mail)
      (phone.number !voice) (bool !t-user) (bool !t-room)
      (bool !t-dept) (bool !t-voice) (bool !t-mail)
      (bool !t-title) (bool !t-phone)
      (first.initial !fi)
      (firstname !firstname))
     (when
      (and (lastname !person ?lastname)
       (staff.member !person !domain))
      (and
       (observe (state !person "Washington"))
       (observe (country !person "Usa"))
       (observe (city !person "Seattle"))
       (observe (firstname !person !firstname))
       (observe (first.initial !person !fi))
       (observe (lastname !person ?lastname))
       (when (eq !t-user (bool t))
	(and (observe (staff.member !person !domain))
	 (observe (person.domain !person !domain))
	 (observe (userid !person !userid !domain))))
       (when (eq !t-phone (bool t))
	(observe (office.phone !person !phone)))
       (when (eq !t-title (bool t))
	(observe (person.title !person !title)))
       (when (eq !t-room (bool t))
	(observe (office.room !person !room)))
       (when (eq !t-title (bool t))
	(observe (mailbox !person !mail)))
       (when (eq (!t-voice (bool t)))
	(observe (voicemailnum !person !voice) !t-voice))
       (when (eq (!t-dept (bool t)))
	(observe (department !person !dept) !t-dept))))))))

 (interface
  ((translation ("staffdir -full -N " ?lastname))
   (exec-func execute-unix-command)
   (error-func staffdir-error)
   (logical-sense-call t)
   (sense-func ((!person !firstname !userid
		 !domain !t-user !room !t-room !phone !t-phone
		 !title !t-title !dept !t-dept
		 !mail !t-mail !voice !t-voice !fi)
		(staffdir-sense :new ?lastname))))))

(defoperator PERSON-OFFICE-ROOM ((person ?person) (room.number !room))
 (declare ((userid ?userid) (domain ?domain)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (current.domain ?domain))
	   (satisfy (userid ?person ?userid ?domain?))))
 (effect (and (observe (office.room ?person !room))))
 (interface
  ((translation ("grep " ?userid "/cse/student-affairs/mailing-lists/room-*.dis"))
   (exec-func execute-unix-command)
   (logical-sense-call t)
   (sense-func ((!room) (person-office-room-sense ?userid))))))

(defoperator USERS-IN-ROOM ((room.number ?room))
 (precond (and (satisfy (current.shell csh))))
 (effect (forall ((userid !uid))
	  (when (userid.room !uid ?room)
	   (observe (userid.room !uid ?room)))))
 (interface
  ((translation ("cat /cse/student-affairs/mailing-lists/room-"
		 ?room ".dis"))
   (exec-func execute-unix-command)
   (logical-sense-call t)
   (sense-func ((!uid) (users-in-room-sense))))))

(defoperator PEOPLE-IN-ROOM ((room.number ?room))
 (declare ((person ?person) (userid ?userid) (domain ?domain)))
 (precond (and
	   (satisfy (userid.room ?userid ?room?))
	   (satisfy (current.domain ?domain))
	   (satisfy (userid ?person ?userid? ?domain?))
	   (satisfy (person.domain ?person ?domain?))
	   ))
 (effect (observe (office.room ?person ?room))))

(defoperator INFER-OFFICE-PHONE-FROM-FINGER-REC ((person ?person)
						 (phone.number !phone)
						 (bool !phone-t))
 (declare ((finger.record ?f-rec) (domain ?domain)))
 (precond (and (satisfy (finger.record ?person? ?f-rec ?domain))))
 (effect
  (observe (office.phone ?person !phone) !phone-t))
 (interface
  ((exec-func execute-lisp-command-no-vcs)
   (translation (stringify ?f-rec))
   (sense-func ((!phone !phone-t)
		(office-phone-from-finger-rec-sense ?f-rec))))))

(defoperator INFER-HOME-PHONE-FROM-FINGER-REC ((person ?person)
					       (phone.number !phone)
					       (bool !phone-t))
 (declare ((finger.record ?f-rec) (domain ?domain)))
 (precond (and
	   (satisfy (finger.record ?person? ?f-rec ?domain))))
 (effect
  (observe (home.phone ?person !phone) !phone-t))
 (interface
  ((exec-func execute-lisp-command-no-vcs)
   (translation (stringify ?f-rec))
   (sense-func ((!phone !phone-t)
		(home-phone-from-finger-rec-sense ?f-rec))))))

(defoperator INFER-OFFICE-PHONE-SHARED ((person ?person)
					(phone.number ?phone))
 (declare ((person ?officemate) (room.number ?shared-room)))
 (precond
  (and (neq ?person ?officemate)
   (satisfy (office.room ?person ?shared-room))
   (satisfy (office.room ?officemate? ?shared-room?))
   (satisfy (office.phone ?officemate? ?phone))))
 (effect
  (observe (office.phone ?person ?phone))))

(defoperator userid-login-machines ((machine ?machine)
				    (machine !machine))
 (declare ((userid ?userid) (machine.name ?name)))
 (precond (and
	   (satisfy (machine.name ?machine? ?name))
	   (satisfy (machine.alive ?machine?))

	   (satisfy (machine.domain ?machine? "cs.washington.edu"))))
 (effect (forall ((machine !machine))
	  (exists
	   ((machine.name !name))
	   (when (userid.login.machine ?userid ?machine !machine)
	    (and
	     (observe (userid.login.machine ?userid
		       ?machine !machine))
	     (observe (machine.name !machine !name)))))))
 (interface
  ((translation
    ("rsh " ?name " \"who /var/adm/wtmp | grep "
     ?userid " | tail -50\""))
   (exec-func execute-unix-command)
   (logical-sense-call t)
   (sense-func ((!machine !name)
		(sense-userid-login-machines ?userid :new))))))

(defoperator PING ((string ?machine-name)
		   (machine !machine))
 (declare ((machine.nickname !nickname) (domain !domain) (bool !tv)
	   (machine.name !name)))
 (precond (satisfy (current.shell csh)))
 (effect
  (when (or (and (machine.name !machine ?machine-name)
	     (domain.machine.name !domain !name))
	 (and (machine.domain !machine !domain)
	  (current.domain !domain)
	  (domain.name.nickname !domain !name !nickname)
	  (machine.nickname !machine ?machine-name)))
   (and (observe (machine.alive !machine) !tv)
    (when (machine.alive !machine)
     (and
      (observe (machine.name !machine !name))
      (observe (machine.nickname !machine !nickname))
      (observe (machine.domain !machine !domain)))))))
 (interface ((exec-func execute-unix-command)
	     (translation ("/usr/etc/ping " ?machine-name))
	     (logical-sense-call t)
	     (sense-func ((!tv !machine !name !nickname !domain)
			  (ping-machine-sense :new ?machine-name))))))

(defoperator FINGER-MACHINE ((machine ?machine))
 (declare ((machine.name ?machine-name)))
 (precond (and (satisfy (current.shell csh))
	   (contemplate (is-bound ?machine))
	   (satisfy (machine.alive ?machine?))
	   (satisfy (machine.name ?machine? ?machine-name))
	   (contemplate (machine.unfingerable ?machine) u)))
 (effect (and
	  (forall ((userid !uid))
	   (when (logged.on !uid ?machine)
	    (observe (logged.on !uid ?machine))))
	  (forall ((userid !uid) (number !idle-time))
	   (when
	    (idle.time !uid ?machine !idle-time)
	    (observe (idle.time !uid ?machine !idle-time))))
	  (forall ((userid !uid) )
	   (when (active.on !uid ?machine)
	    (observe (active.on !uid ?machine))))))
 (interface ((exec-func execute-unix-command)
	     (sense-func (((!uid) (!uid !idle-time) (!uid))
			  (finger-machine-sense ?machine)))
	     (logical-sense-call t)
	     (error-func finger-error)
	     (translation ("finger @" ?machine-name)))))

(defoperator HOSTNAME ((machine !host))
 (declare ((machine.name !n) (domain ?domain-name)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (current.domain ?domain-name))))
 (effect (when (current.host !host)
	  (and (observe (machine.name !host !n))
	   (observe (current.host !host)))))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!host !n) (hostname-sense
				      :new ?domain-name)))
	     (translation ("hostname")))))

(defoperator UPTIME ((machine ?m1) (number !load)
		     (number !user-num))
 (declare ((machine.name ?n1)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (machine.name ?m1? ?n1))))
 (effect (and (observe (load ?m1 !load))
	  (observe (users ?m1 !user-num))))
 (interface ((exec-func execute-unix-command)
	     (sense-func ((!load !user-num) uptime-sense))
	     (error-func null-function)
	     (translation ("rsh " ?n1 " uptime")))))

(defoperator MACHINE ((string !type))
 (precond (satisfy (current.shell csh)))
 (effect (observe (current.machine.type !type)))
 (interface ((exec-func execute-unix-command)
	     (sense-func ((!type) machine-sense))
	     (translation ("machine")))))

(defoperator HINFO nil
 (declare ((domain ?domain)))
 (precond
  (and (satisfy (current.shell csh))
   (satisfy (current.domain ?domain))))
 (effect
  (and
   (forall ((machine !m))
    (exists
     ((machine.name !name)
      (machine.nickname !nickname) (domain ?domain)
      (bool !tv-xterm) (machine.model !model)
      (bool !unfingerable) (bool !unrshable)
      (string !room) (room.number !room-number))
     (when (machine.domain !m ?domain)
      (and
       (observe (machine.nickname !m !nickname))
       (observe (machine.xterm !m) !tv-xterm)
       (observe (machine.unrshable !m) !unrshable)
       (observe (machine.unfingerable !m) !unfingerable)
       (observe (machine.name !m !name))
       (observe (machine.domain !m ?domain))
       (observe (machine.room !m !room))
       (observe (machine.room.number !m !room-number))
       (observe (machine.model !m !model))
       (forall ((userid !admin))
	(when (machine.admin !m !admin)
	 (observe (machine.admin !m !admin))))
       (forall ((op.sys !op-sys))
	(when (machine.op.sys !m !op-sys)
	 (observe (machine.op.sys !m !op-sys))))
       (forall ((display.color !color))
	(when (machine.color !m !color)
	 (observe (machine.color !m !color))))))))))
 (interface ((exec-func execute-unix-command)
	     (sense-func ((!m !name !tv-xterm
			   !nickname !model !room !room-number
			   !unfingerable
			   (!admin) (!op-sys)
			   (!color))
			  (hinfo-all-sense ?domain :new)))
	     (logical-sense-call t)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (translation ("hinfo")))))

(defoperator FIND-DOMAIN ((machine ?machine) (domain !domain))
 (declare ((machine.name ?m-name)))
 (precond (satisfy (machine.name ?machine? ?m-name)))
 (effect (observe (machine.domain ?machine !domain)))
 (interface ((exec-func execute-lisp-command-no-vcs)
	     (sense-func ((!domain) bind-output-to-string))
	     (translation (find-domain-name ?m-name)))))

(defoperator LPR ((printer ?printer) (simple.file ?file))
 (declare ((printer.name ?printer-name)
	   (path ?pathname)
	   (filename ?filename)
	   (pstext ?ps)
	   (dvi.document ?dvi)
	   (document ?doc)
	   (print.job !printout)
	   (string ?option)
	   (print.job ?printout)
	   (string !jobname)
	   (directory ?parent-dir)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (pathname ?file ?pathname))
	   (satisfy (filename ?file ?filename))
	   (satisfy (printer.name ?printer ?printer-name))
	   (satisfy (located.at ?doc ?pathname))
	   (or (and (eq ?doc ?dvi) (eq ?option " -d "))
	    (and (eq ?doc ?ps) (eq ?option " ")))))
 (effect (and (cause (printed ?file ?printer))
	  (when (and (job.name ?printout !jobname)
		 (job.printer ?printout ?printer))
	   (and (cause (document.job ?doc ?printout))
	    (when (and (iscolor ?printer) (iscolor ?doc))
	     (cause (iscolor ?printout)))))))
 (interface ((exec-func execute-unix-command)
	     (sense-func ((!jobname) (lpr-sense ?filename)))
	     (translation ("lpr -h -P" ?printer-name
			   ?option ?pathname)))))

(defoperator lpq (?printer)
 (declare ((printer.name ?printer-name)
	   (print.job !job)
	   (print.job !done-job)
	   (string !job-name)
	   (number !job-number)
	   (thing !job-status)
	   (userid !job-user)
	   (status !job-status)
	   (status !status)
	   (status !queue-status)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (printer.name ?printer ?printer-name))))
 (effect (and (observe (print.queue.status ?printer !queue-status))
	  (observe (printer.status ?printer !status))
	  (forall ((print.job !job))
	   (when (and (job.printer !job ?printer)
		  (job.status !job working))
	    (and (observe (job.name !job !job-name))
	     (observe (job.number !job !job-number))
	     (observe (job.user !job !job-user))
	     (observe (job.printer !job ?printer))
	     (observe (job.status !job working)))))))
 (interface ((exec-func execute-unix-command)
	     (logical-sense-call t)
	     (sense-func (!status !queue-status
			  (!job !job-number !job-name !job-user)

			  (lpq-sense :new)))
	     (translation ("lpq -P" ?printer-name)))))

(defoperator get-web-page ((url ?url) (http.text !text))
 (declare ((web.page ?www)))
 (precond (satisfy (current.shell csh)))
 (effect (when (located.at ?www ?url)
	  (and (observe (contents ?www !text))
	   (observe (located.at ?www ?url)))))
 (interface ((exec-func execute-unix-command)
	     (translation ("lynx -source " ?url))
	     (logical-sense-call t)
	     (sense-func (!text (output)))
	     (error-func no-error)
	     (terminate-detect read-unix-prompt))))

(defoperator get-urls-in-page ((web.page ?p))
 (declare ((http.text ?text)))
 (precond (and (satisfy (contents ?p? ?text))
	   (satisfy (located.at ?p ?pu))))
 (effect (forall ((web.page !child))
	  (exists ((url !u) (string !name))
	   (when (points.to ?p !child)
	    (and (observe (points.to ?p !child))
	     (observe (name !child !name))
	     (observe (located.at !child !u)))))))
 (interface ((exec-func execute-lisp-command-no-vcs)
	     (translation (identity ?text))
	     (logical-sense-call t)
	     (sense-func ((!child !u !name)
			  (scan-for-urls :new ?pu)))
	     (error-func no-error)
	     (terminate-detect read-unix-prompt))))

(defoperator web-ftp-file-info ((ftp.directory !d))
 (declare ((url ?url)))
 (precond (and (satisfy (current.shell csh))))
 (effect (when (located.at !d ?url)
	  (and (observe (located.at !d ?url))
	   (forall ((ftp.file !f))
	    (exists ((url !u)
		     (minute !minute)
		     (hour !hour)
		     (date !day)
		     (month !month)
		     (year !year)
		     (time !t)
		     (filename !n))
	     (when (points.to !d !f)
	      (and
	       (observe (points.to !d !f))
	       (observe (located.at !f !u))
	       (observe (creation.date !f !t))
	       (observe (month !t !month))
	       (observe (date !t !day))
	       (observe (year !t !year))
	       (observe (hour !t !hour))
	       (observe (minute !t !minute))
	       (observe (name !f !n)))))))))
 (interface ((exec-func execute-unix-command)
	     (translation ("lynx -source " ?url))
	     (logical-sense-call t)
	     (sense-func (!d (!t !month !year
			      !day !hour !minute !u !n !f)
			  (ftp-sense :new :new :new)))
	     (error-func no-error)
	     (terminate-detect read-unix-prompt))))

(defoperator save-web-page ((document ?f)
			    (directory ?dir))
 (declare ((url ?url)
	   (directory ?dir)
	   (path ?path)
	   (path ?dirname)
	   (filename ?n)
	   (file ?random)))
 (precond (and (satisfy (located.at ?f? ?url))
	   (satisfy (pathname ?dir ?dirname))
	   (satisfy (name ?f ?n))
	   (satisfy (concat ?dirname? "/" ?n? ?path))))
 (effect (exists ((file !local))
	  (and (cause (copy.of ?f !local ?dir))
	   (cause (parent.directory !local ?dir))
	   (cause (pathname !local ?path))
	   (cause (filename !local ?n)))))
 (interface ((exec-func execute-unix-command)
	     (translation ("lynx -source " ?url " >! " ?path))
	     (sense-func ((!local) (ident :new))))))

(defoperator xless ((path ?filepath))
 (documentation "Xless displays text files")
 (declare ((simple.file ?file) (text.document ?doc)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (located.at ?doc ?filepath))
	   ))
 (effect (cause (displayed ?doc)))
 (interface ((exec-func execute-unix-command)
	     (error-func default-unix-error?)
	     (translation ("xless " ?filepath))
	     ))
 )

(defoperator ghostview ((path ?filepath))
 (documentation "Ghostview displays Postscript Files")
 (declare ((simple.file ?file) (postscript.document ?doc)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (located.at ?doc ?filepath))
	   ))
 (effect (cause (displayed ?doc)))
 (interface ((exec-func execute-unix-command)
	     (error-func no-error)
	     (translation ("ghostview " ?filepath))
	     ))
 )

(defoperator xv ((path ?filepath))
 (documentation "XV displays some graphical image type files")
 (declare ((simple.file ?file) (image.document ?doc)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (located.at ?doc ?filepath))))
 (effect (cause (displayed ?doc)))
 (interface ((exec-func execute-unix-command)
	     (error-func default-unix-error?)
	     (translation ("xv " ?filepath))
	     ))
 )

(defoperator xdvi ((path ?filepath))
 (documentation "Xdvi displays DVI files from TeX")
 (declare ((simple.file ?file) (dvi.document ?doc)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (located.at ?doc ?filepath))
	   ))
 (effect (cause (displayed ?doc)))
 (interface ((exec-func execute-unix-command)
	     (error-func default-unix-error?)
	     (translation ("xdvi " ?filepath))
	     ))
 )

(defoperator mpeg.play ((path ?filepath))
 (documentation "Mpeg_play displays mpeg format animation files")
 (declare ((simple.file ?file) (animation.document ?doc)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (located.at ?doc ?filepath))
	   ))
 (effect (cause (displayed ?doc)))
 (interface ((exec-func execute-unix-command)
	     (error-func mpeg.play-error)
	     (translation ("mpeg_play " ?filepath " ; echo \newline"))
	     ))
 )

(defoperator netscape ((string ?filepath))
 (documentation "Display document using Netscape")
 (declare ((simple.file ?file) (web.page ?doc)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (located.at ?doc ?filepath))
	   ))
 (effect (cause (displayed ?doc)))
 (interface ((exec-func execute-unix-command)
	     (error-func default-unix-error?)
	     (translation ("netscape -remote \"openURL("
			   ?filepath ")\"" ))
	     ))
 )

(defoperator file-type ((path ?filepath))
 (documentation "Find out type of document contained in file")
 (declare ((simple.file ?file) (document !doc) (string ?type)))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (pathname ?file ?filepath))))
 (effect (observe (located.at !doc ?filepath)))
 (interface ((exec-func execute-unix-command)
	     (error-func find-file-type-error)
	     (logical-sense-call t)
	     (translation ("file " ?filepath))
	     (sensor-bind-func xii::my-get-sense-bindings)
	     (sense-func ((!doc) (file-sense ?filepath :new)))
	     (error-func no-error)
	     )))

(defoperator latex ((path ?filepath))
 (documentation "Converts latex files to dvi files")
 (declare ((simple.file !dvifile)
	   (simple.file ?file)
	   (path ?dvipath)
	   (directory ?dir)
	   (tex.document ?doc)
	   (dvi.document !dvidoc)
	   ))
 (precond (and (satisfy (string.in.file "\batchmode" ?file?))
	   (satisfy (located.at ?doc ?filepath))
	   (satisfy (pathname ?file ?filepath))
	   (satisfy (latexed.path ?filepath ?dvipath))
	   ))
 (effect (and (cause (pathname !dvifile ?dvipath))
	  (cause (located.at !dvidoc ?dvipath))
	  (cause (derived.from !dvidoc ?doc))
	  (when (title ?doc ?title)
	   (cause (title !dvidoc ?title)))
	  (when (author ?doc ?author)
	   (cause (author !dvidoc ?author)))
	  ))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!dvifile !dvidoc)

			  (converter-sense :new :new)))
	     (error-func default-unix-error?)
	     (translation ("latex2e " ?filepath))
	     ))
 )

(defoperator dvips ((path ?filepath))
 (documentation "Converts latex dvi files to postscript")
 (declare ((simple.file !psfile)
	   (simple.file ?file)
	   (path ?pspath)
	   (directory ?dir)
	   (dvi.document ?doc)
	   (postscript.document !psdoc)
	   ))
 (precond (and (satisfy (current.shell csh))
	   (satisfy (located.at ?doc ?filepath))
	   (satisfy (pathname ?file ?filepath))
	   (sense (dvitps.path ?filepath ?pspath))
	   (satisfy (file.type ?file "data"))
	   ))
 (effect (and (cause (pathname !psfile ?pspath))
	  (cause (located.at !psdoc ?pspath))
	  (cause (derived.from !psdoc ?doc))
	  (when (title ?doc ?title)
	   (cause (title !psdoc ?title)))
	  (when (author ?doc ?author)

	   (cause (author !psdoc ?author)))
	  ))
 (interface ((exec-func execute-unix-command)
	     (sensor-bind-func ucpop::my-get-sense-bindings)
	     (sense-func ((!psfile !psdoc)
			  (converter-sense :new :new)))
	     (error-func default-unix-error?)
	     (translation ("dvitps -o" ?pspath " " ?filepath))
	     ))
 )
